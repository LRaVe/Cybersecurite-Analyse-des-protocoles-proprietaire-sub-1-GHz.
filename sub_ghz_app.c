#include <furi.h>
#include <furi_hal.h>
#include <gui/gui.h>
#include <input/input.h>
#include <storage/storage.h>
#include <toolbox/stream/file_stream.h>
#include <furi_hal_gpio.h>

// Tag pour les logs (visible via CLI: log context SubGhzApp)
#define TAG "SubGhzApp"

// Fréquence d'écoute (433.92 MHz)
#define MY_FREQUENCY         433920000
#define SUBGHZ_RAW_FILE_PATH "/ext/subghz/captures/capture.sub"

/* generated by fbt from .png files in images folder */
#include <sub_ghz_app_icons.h>

typedef struct {
    ViewPort* view_port;
    Gui* gui;
    FuriMessageQueue* event_queue;
    bool is_capturing;
    uint32_t signal_count;
    FuriString* file_path;
    FuriThread* worker_thread;
    uint8_t app_state; // 0: Capture, 1: Affichage, 2: Replay
    FuriString* display_content;
    bool is_replaying;
    uint32_t replay_count;
} SubGhzApp;

// --- Callback de l'interface graphique (GUI) ---
static void render_callback(Canvas* canvas, void* ctx) {
    SubGhzApp* app = ctx;
    canvas_clear(canvas);
    canvas_set_font(canvas, FontPrimary);

    if(app->app_state == 0) {
        // Mode Capture
        canvas_draw_str(canvas, 2, 10, "SubGhz Capture");
        canvas_set_font(canvas, FontSecondary);

        FuriString* status = furi_string_alloc();
        if(app->is_capturing) {
            furi_string_printf(status, "Status: CAPTURING");
            canvas_draw_str(canvas, 2, 25, furi_string_get_cstr(status));
            furi_string_printf(status, "Signals: %lu", app->signal_count);
            canvas_draw_str(canvas, 2, 38, furi_string_get_cstr(status));
        } else {
            canvas_draw_str(canvas, 2, 25, "Status: IDLE");
            furi_string_printf(status, "Saved: %lu signals", app->signal_count);
            canvas_draw_str(canvas, 2, 38, furi_string_get_cstr(status));
        }
        furi_string_free(status);

        canvas_draw_str(canvas, 2, 52, "OK: Start/Stop");
        canvas_draw_str(canvas, 2, 62, "Left: View Records");
    } else if(app->app_state == 1) {
        // Mode Affichage des enregistrements
        canvas_draw_str(canvas, 2, 10, "Saved Recordings");
        canvas_set_font(canvas, FontSecondary);
        canvas_draw_str(canvas, 2, 25, furi_string_get_cstr(app->display_content));
        canvas_draw_str(canvas, 2, 52, "OK: Replay");
        canvas_draw_str(canvas, 2, 62, "Back: Return");
    } else if(app->app_state == 2) {
        // Mode Replay
        canvas_draw_str(canvas, 2, 10, "Replay Signal");
        canvas_set_font(canvas, FontSecondary);

        if(app->is_replaying) {
            canvas_draw_str(canvas, 2, 25, "Status: REPLAYING");
            FuriString* replay_status = furi_string_alloc();
            furi_string_printf(replay_status, "Count: %lu", app->replay_count);
            canvas_draw_str(canvas, 2, 38, furi_string_get_cstr(replay_status));
            furi_string_free(replay_status);
        } else {
            canvas_draw_str(canvas, 2, 25, "Status: READY");
            canvas_draw_str(canvas, 2, 38, "Press OK to transmit");
        }
        canvas_draw_str(canvas, 2, 52, "OK: Send Signal");
        canvas_draw_str(canvas, 2, 62, "Back: Return");
    }
}

// --- Callback des entrées (boutons) ---
static void input_callback(InputEvent* input_event, void* ctx) {
    FuriMessageQueue* event_queue = ctx;
    furi_message_queue_put(event_queue, input_event, FuriWaitForever);
}

// --- Thread de capture qui lit les paquets RF ---
static int32_t subghz_worker_thread(void* context) {
    SubGhzApp* app = context;

    FURI_LOG_I(TAG, "Thread de capture demarre");

    Storage* storage = furi_record_open(RECORD_STORAGE);
    Stream* stream = file_stream_alloc(storage);

    uint8_t packet_buffer[64];
    uint8_t packet_size = 0;
    float rssi = 0;
    uint32_t last_packet_time = 0;

    while(app->is_capturing) {
        // Vérifier activement la réception avec RSSI
        rssi = furi_hal_subghz_get_rssi();

        // Si RSSI détecte un signal (> seuil de bruit)
        if(rssi > -60.0f) {
            uint32_t current_time = furi_get_tick();

            // Éviter les doublons (attendre au moins 50ms entre paquets)
            if(current_time - last_packet_time > 50) {
                app->signal_count++;
                last_packet_time = current_time;

                // Log
                FURI_LOG_I(
                    TAG,
                    "Signal detecte: RSSI=%.1f dBm, count=%lu",
                    (double)rssi,
                    app->signal_count);

                // Essayer de lire le paquet si disponible
                if(furi_hal_subghz_rx_pipe_not_empty()) {
                    packet_size = sizeof(packet_buffer);
                    furi_hal_subghz_read_packet(packet_buffer, &packet_size);

                    if(packet_size > 0) {
                        FURI_LOG_I(TAG, "Paquet recu: %u octets", packet_size);
                    }
                }

                // Sauvegarder les données
                if(file_stream_open(
                       stream,
                       furi_string_get_cstr(app->file_path),
                       FSAM_WRITE,
                       FSOM_OPEN_APPEND)) {
                    FuriString* line = furi_string_alloc();

                    if(packet_size > 0) {
                        furi_string_printf(line, "RAW_Data: ");
                        for(size_t i = 0; i < packet_size; i++) {
                            furi_string_cat_printf(line, "%02X ", packet_buffer[i]);
                        }
                        furi_string_cat_printf(line, "\n");
                    } else {
                        // Enregistrer juste la détection RSSI
                        furi_string_printf(line, "RAW_Signal: RSSI=%.1f dBm\n", (double)rssi);
                    }

                    stream_write_string(stream, line);
                    furi_string_free(line);
                    file_stream_close(stream);
                }

                packet_size = 0;
            }
        }

        // Flush périodique
        if(furi_hal_subghz_rx_pipe_not_empty()) {
            furi_hal_subghz_flush_rx();
        }

        furi_delay_ms(5); // Vérifier toutes les 5ms pour meilleure réactivité
    }

    stream_free(stream);
    furi_record_close(RECORD_STORAGE);
    FURI_LOG_I(TAG, "Thread de capture arrete");
    return 0;
}

// --- Démarrer la capture ---
static void start_capture(SubGhzApp* app) {
    FURI_LOG_I(TAG, "Demarrage de la capture...");

    // Initialiser le sous-système SubGhz
    furi_hal_subghz_reset();
    furi_hal_subghz_idle();

    // Configurer la fréquence
    furi_hal_subghz_set_frequency_and_path(MY_FREQUENCY);

    // Configurer le GPIO GDO0 du CC1101 en mode input pour capturer les données
    furi_hal_gpio_init(&gpio_cc1101_g0, GpioModeInput, GpioPullNo, GpioSpeedHigh);

    furi_hal_subghz_flush_rx();
    furi_hal_subghz_rx();

    // Créer le fichier de capture
    Storage* storage = furi_record_open(RECORD_STORAGE);

    // Créer le répertoire si nécessaire
    storage_common_mkdir(storage, "/ext/subghz");
    storage_common_mkdir(storage, "/ext/subghz/captures");

    // Créer/écraser le fichier avec l'en-tête
    Stream* stream = file_stream_alloc(storage);
    if(file_stream_open(stream, SUBGHZ_RAW_FILE_PATH, FSAM_WRITE, FSOM_CREATE_ALWAYS)) {
        stream_write_cstring(stream, "Filetype: Flipper SubGhz RAW File\n");
        stream_write_cstring(stream, "Version: 1\n");
        FuriString* freq_line = furi_string_alloc();
        furi_string_printf(freq_line, "Frequency: %u\n", MY_FREQUENCY);
        stream_write_string(stream, freq_line);
        stream_write_cstring(stream, "Preset: FuriHalSubGhzPresetOok650Async\n");
        stream_write_cstring(stream, "Protocol: RAW\n");
        furi_string_free(freq_line);
    }
    file_stream_close(stream);
    stream_free(stream);
    furi_record_close(RECORD_STORAGE);

    // Démarrer le thread de capture
    app->is_capturing = true;
    app->signal_count = 0;

    app->worker_thread = furi_thread_alloc();
    furi_thread_set_name(app->worker_thread, "SubGhzWorker");
    furi_thread_set_stack_size(app->worker_thread, 2048);
    furi_thread_set_context(app->worker_thread, app);
    furi_thread_set_callback(app->worker_thread, subghz_worker_thread);
    furi_thread_start(app->worker_thread);

    FURI_LOG_I(TAG, "Capture demarree sur %u Hz", MY_FREQUENCY);
} // --- Arrêter la capture ---
static void stop_capture(SubGhzApp* app) {
    if(app->is_capturing) {
        FURI_LOG_I(TAG, "Arret de la capture...");

        app->is_capturing = false;

        // Attendre la fin du thread
        furi_thread_join(app->worker_thread);
        furi_thread_free(app->worker_thread);

        furi_hal_subghz_sleep();

        FURI_LOG_I(
            TAG,
            "Capture arretee. %lu signaux sauvegardes dans %s",
            app->signal_count,
            SUBGHZ_RAW_FILE_PATH);
    }
}

// --- Fonction pour charger et afficher les enregistrements ---
static void load_recordings(SubGhzApp* app) {
    FURI_LOG_I(TAG, "Chargement des enregistrements...");

    furi_string_reset(app->display_content);

    Storage* storage = furi_record_open(RECORD_STORAGE);
    Stream* stream = file_stream_alloc(storage);

    if(file_stream_open(stream, SUBGHZ_RAW_FILE_PATH, FSAM_READ, FSOM_OPEN_EXISTING)) {
        uint64_t file_size = stream_size(stream);

        // Afficher la taille du fichier
        furi_string_printf(app->display_content, "File size: %llu bytes\n", file_size);
        furi_string_cat_printf(app->display_content, "Signals: %lu\n\n", app->signal_count);

        // Lire les 10 premières lignes
        FuriString* line = furi_string_alloc();
        int line_count = 0;

        while(stream_read_line(stream, line) && line_count < 10) {
            furi_string_cat_printf(app->display_content, "%s", furi_string_get_cstr(line));
            line_count++;
        }

        if(line_count == 10) {
            furi_string_cat_printf(app->display_content, "...\n");
        }

        furi_string_free(line);
        FURI_LOG_I(TAG, "Fichier charge avec succes");
    } else {
        furi_string_printf(app->display_content, "Fichier non trouve:\n%s", SUBGHZ_RAW_FILE_PATH);
        FURI_LOG_W(TAG, "Impossible de charger le fichier");
    }

    file_stream_close(stream);
    stream_free(stream);
    furi_record_close(RECORD_STORAGE);
}

// --- Fonction pour rejouer les signaux enregistrés ---
static int32_t subghz_replay_thread(void* context) {
    SubGhzApp* app = context;

    FURI_LOG_I(TAG, "Demarrage du replay...");

    // Initialiser la radio en mode TX
    furi_hal_subghz_reset();
    furi_hal_subghz_set_frequency_and_path(MY_FREQUENCY);

    Storage* storage = furi_record_open(RECORD_STORAGE);
    Stream* stream = file_stream_alloc(storage);

    if(file_stream_open(stream, SUBGHZ_RAW_FILE_PATH, FSAM_READ, FSOM_OPEN_EXISTING)) {
        FuriString* line = furi_string_alloc();
        uint32_t replay_count = 0;

        // Sauter les en-têtes
        while(stream_read_line(stream, line)) {
            if(furi_string_search_char(line, ':') == FURI_STRING_FAILURE) {
                break; // Fin des en-têtes
            }
        }

        // Lire et rejouer les données RAW
        while(stream_read_line(stream, line) && app->is_replaying) {
            // Chercher les lignes RAW_Data
            if(furi_string_search_str(line, "RAW_Data") != FURI_STRING_FAILURE) {
                // Parser la ligne: "RAW_Data: 1 50000" ou "RAW_Signal: RSSI=-60.0"
                const char* data_ptr = furi_string_get_cstr(line);

                // Ignorer les signaux RSSI, traiter seulement RAW_Data avec niveau
                if(strstr(data_ptr, "RAW_Data:") != NULL) {
                    int level = 0;
                    uint32_t duration = 0;

                    // Parser: "RAW_Data: 1 50000"
                    if(sscanf(data_ptr, "RAW_Data: %d %lu", &level, &duration) == 2) {
                        // Envoyer le signal via le CC1101
                        if(level != 0) {
                            // Transmettre à la fréquence configurée
                            furi_hal_subghz_idle();
                            furi_hal_subghz_tx();
                            furi_delay_us(duration);
                            furi_hal_subghz_idle();
                        } else {
                            // Pause
                            furi_delay_us(duration);
                        }

                        replay_count++;
                        app->replay_count = replay_count;

                        if(replay_count % 10 == 0) {
                            FURI_LOG_D(TAG, "Replay: %lu signaux envoyes", replay_count);
                        }
                    }
                }
            }
        }

        furi_string_free(line);
        FURI_LOG_I(TAG, "Replay termine: %lu signaux transmis", replay_count);
    } else {
        FURI_LOG_E(TAG, "Impossible de lire le fichier de capture");
    }

    file_stream_close(stream);
    stream_free(stream);
    furi_record_close(RECORD_STORAGE);

    furi_hal_subghz_idle();
    furi_hal_subghz_sleep();

    app->is_replaying = false;
    return 0;
}

// --- Point d'entrée principal ---
int32_t sub_ghz_app(void* p) {
    UNUSED(p);

    FURI_LOG_I(TAG, "SubGhz App demarree");

    // Initialiser la structure de l'app
    SubGhzApp* app = malloc(sizeof(SubGhzApp));
    app->is_capturing = false;
    app->signal_count = 0;
    app->file_path = furi_string_alloc_set(SUBGHZ_RAW_FILE_PATH);
    app->event_queue = furi_message_queue_alloc(8, sizeof(InputEvent));
    app->app_state = 0; // Mode capture par défaut
    app->display_content = furi_string_alloc();
    app->is_replaying = false;
    app->replay_count = 0;

    // Mise en place de l'interface graphique
    app->view_port = view_port_alloc();
    view_port_draw_callback_set(app->view_port, render_callback, app);
    view_port_input_callback_set(app->view_port, input_callback, app->event_queue);

    app->gui = furi_record_open(RECORD_GUI);
    gui_add_view_port(app->gui, app->view_port, GuiLayerFullscreen);

    // Boucle d'événements
    InputEvent event;
    bool running = true;
    while(running) {
        if(furi_message_queue_get(app->event_queue, &event, 100) == FuriStatusOk) {
            if(event.type == InputTypeShort) {
                if(event.key == InputKeyBack) {
                    if(app->app_state == 0) {
                        running = false;
                    } else if(app->app_state == 2 && app->is_replaying) {
                        // Arrêter le replay en cours
                        app->is_replaying = false;
                        app->app_state = 1; // Retourner au mode affichage
                    } else {
                        // Revenir au mode capture
                        app->app_state = 0;
                    }
                    view_port_update(app->view_port);
                } else if(event.key == InputKeyOk && app->app_state == 0) {
                    // Basculer la capture (seulement en mode capture)
                    if(app->is_capturing) {
                        stop_capture(app);
                    } else {
                        start_capture(app);
                    }
                    view_port_update(app->view_port);
                } else if(event.key == InputKeyOk && app->app_state == 1) {
                    // Passer au mode replay depuis affichage
                    app->app_state = 2;
                    app->is_replaying = true;
                    app->replay_count = 0;

                    // Démarrer le thread de replay
                    FuriThread* replay_thread = furi_thread_alloc();
                    furi_thread_set_name(replay_thread, "SubGhzReplay");
                    furi_thread_set_stack_size(replay_thread, 2048);
                    furi_thread_set_context(replay_thread, app);
                    furi_thread_set_callback(replay_thread, subghz_replay_thread);
                    furi_thread_start(replay_thread);
                    furi_thread_join(replay_thread);
                    furi_thread_free(replay_thread);

                    view_port_update(app->view_port);
                } else if(event.key == InputKeyOk && app->app_state == 2) {
                    // Envoyer le signal (si pas déjà en cours)
                    if(!app->is_replaying) {
                        app->is_replaying = true;
                        app->replay_count = 0;

                        FuriThread* replay_thread = furi_thread_alloc();
                        furi_thread_set_name(replay_thread, "SubGhzReplay");
                        furi_thread_set_stack_size(replay_thread, 2048);
                        furi_thread_set_context(replay_thread, app);
                        furi_thread_set_callback(replay_thread, subghz_replay_thread);
                        furi_thread_start(replay_thread);
                        furi_thread_join(replay_thread);
                        furi_thread_free(replay_thread);
                    }
                    view_port_update(app->view_port);
                } else if(event.key == InputKeyLeft && app->app_state == 0) {
                    // Afficher les enregistrements
                    app->app_state = 1;
                    load_recordings(app);
                    view_port_update(app->view_port);
                }
            }
        }

        // Mettre à jour l'affichage si en cours de capture
        if(app->is_capturing) {
            view_port_update(app->view_port);
        }
    }

    // Nettoyage
    FURI_LOG_I(TAG, "Arret de l'app");

    if(app->is_capturing) {
        stop_capture(app);
    }

    gui_remove_view_port(app->gui, app->view_port);
    view_port_free(app->view_port);
    furi_record_close(RECORD_GUI);
    furi_message_queue_free(app->event_queue);
    furi_string_free(app->file_path);
    furi_string_free(app->display_content);
    free(app);

    return 0;
}
