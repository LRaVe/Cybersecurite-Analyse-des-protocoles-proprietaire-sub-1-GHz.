#include <furi.h>
#include <furi_hal.h>
#include <gui/gui.h>
#include <input/input.h>
#include <storage/storage.h>
#include <toolbox/stream/file_stream.h>
#include <furi_hal_gpio.h>
#include <lib/toolbox/level_duration.h>
#include <lib/subghz/devices/cc1101_configs.h>
#include <stdlib.h>

// Tag pour les logs (visible via CLI: log context SubGhzApp)
#define TAG "SubGhzApp"

// Fréquence d'écoute (433.92 MHz)
#define MY_FREQUENCY         433920000
#define SUBGHZ_RAW_FILE_PATH "/ext/subghz/captures/capture.sub"

// Seuil RSSI pour détection de signal (en dBm)
#define RSSI_THRESHOLD -70.0f

// Taille du buffer pour les timings RAW (en nombre de transitions)
#define RAW_BUFFER_SIZE 8192

/* generated by fbt from .png files in images folder */
#include <sub_ghz_app_icons.h>

typedef struct {
    ViewPort* view_port;
    Gui* gui;
    FuriMessageQueue* event_queue;
    bool is_capturing;
    uint32_t signal_count;
    FuriString* file_path;
    FuriThread* worker_thread;
    uint8_t app_state; // 0: Capture, 1: Affichage, 2: Replay
    FuriString* display_content;
    volatile bool is_replaying;
    volatile bool replay_finished;
    uint32_t replay_count;
    FuriThread* replay_thread;

    // Buffer pour capture async
    int32_t* raw_buffer;
    volatile size_t raw_buffer_write;
    volatile size_t raw_buffer_read;
    volatile bool capture_started;

    // Buffer pour replay async
    int32_t* tx_buffer;
    size_t tx_buffer_size;
    volatile size_t tx_buffer_index;
    volatile int tx_repeat_current;
} SubGhzApp;

// Variable globale pour le contexte (nécessaire pour certains callbacks)
static SubGhzApp* g_app = NULL;

// --- Callback de l'interface graphique (GUI) ---
static void render_callback(Canvas* canvas, void* ctx) {
    SubGhzApp* app = ctx;
    canvas_clear(canvas);
    canvas_set_font(canvas, FontPrimary);

    if(app->app_state == 0) {
        // Mode Capture
        canvas_draw_str(canvas, 2, 10, "SubGhz Capture");
        canvas_set_font(canvas, FontSecondary);

        FuriString* status = furi_string_alloc();
        if(app->is_capturing) {
            furi_string_printf(status, "Status: CAPTURING");
            canvas_draw_str(canvas, 2, 25, furi_string_get_cstr(status));
            furi_string_printf(status, "Signals: %lu", app->signal_count);
            canvas_draw_str(canvas, 2, 38, furi_string_get_cstr(status));
        } else {
            canvas_draw_str(canvas, 2, 25, "Status: IDLE");
            furi_string_printf(status, "Saved: %lu signals", app->signal_count);
            canvas_draw_str(canvas, 2, 38, furi_string_get_cstr(status));
        }
        furi_string_free(status);

        canvas_draw_str(canvas, 2, 52, "OK: Start/Stop");
        canvas_draw_str(canvas, 2, 62, "Left: View Records");
    } else if(app->app_state == 1) {
        // Mode Affichage des enregistrements
        canvas_draw_str(canvas, 2, 10, "Saved Recordings");
        canvas_set_font(canvas, FontSecondary);
        canvas_draw_str(canvas, 2, 25, furi_string_get_cstr(app->display_content));
        canvas_draw_str(canvas, 2, 52, "OK: Replay");
        canvas_draw_str(canvas, 2, 62, "Back: Return");
    } else if(app->app_state == 2) {
        // Mode Replay
        canvas_draw_str(canvas, 2, 10, "Replay Signal");
        canvas_set_font(canvas, FontSecondary);

        if(app->replay_finished && !app->is_replaying) {
            canvas_draw_str(canvas, 2, 25, "Status: TERMINE !");
            FuriString* replay_status = furi_string_alloc();
            furi_string_printf(replay_status, "Envoyes: %lu signaux", app->replay_count);
            canvas_draw_str(canvas, 2, 38, furi_string_get_cstr(replay_status));
            furi_string_free(replay_status);
            canvas_draw_str(canvas, 2, 52, "OK: Renvoyer");
            canvas_draw_str(canvas, 2, 62, "Back: Retour");
        } else if(app->is_replaying) {
            canvas_draw_str(canvas, 2, 25, "Status: ENVOI EN COURS...");
            FuriString* replay_status = furi_string_alloc();
            furi_string_printf(replay_status, "Signaux: %lu", app->replay_count);
            canvas_draw_str(canvas, 2, 38, furi_string_get_cstr(replay_status));
            furi_string_free(replay_status);
            canvas_draw_str(canvas, 2, 52, "Transmission active");
            canvas_draw_str(canvas, 2, 62, "Back: Annuler");
        } else {
            canvas_draw_str(canvas, 2, 25, "Status: PRET");
            canvas_draw_str(canvas, 2, 38, "Appuyez OK pour envoyer");
            canvas_draw_str(canvas, 2, 52, "OK: Envoyer Signal");
            canvas_draw_str(canvas, 2, 62, "Back: Retour");
        }
    }
}

// --- Callback des entrées (boutons) ---
static void input_callback(InputEvent* input_event, void* ctx) {
    FuriMessageQueue* event_queue = ctx;
    furi_message_queue_put(event_queue, input_event, FuriWaitForever);
}

// --- Callback de capture async - appelé à chaque transition du signal ---
// Variable pour détecter un vrai signal (plusieurs impulsions consécutives)
static uint32_t consecutive_pulses = 0;

static void capture_callback(bool level, uint32_t duration, void* context) {
    SubGhzApp* app = context;

    if(!app->is_capturing) return;

    // Filtrer par durée:
    // - < 150µs = bruit haute fréquence
    // - > 20000µs (20ms) = pause/silence, reset le compteur
    if(duration > 20000) {
        consecutive_pulses = 0;
        return;
    }

    if(duration < 150) {
        consecutive_pulses = 0;
        return;
    }

    // Compter les impulsions consécutives valides (150µs - 20ms)
    consecutive_pulses++;

    // Ne commencer à enregistrer qu'après 30 impulsions valides consécutives
    if(consecutive_pulses < 30) {
        return;
    }

    // Vérifier qu'il reste de la place dans le buffer
    size_t next_write = (app->raw_buffer_write + 1) % RAW_BUFFER_SIZE;
    if(next_write == app->raw_buffer_read) {
        return;
    }

    // Stocker le timing avec signe (positif = HIGH, négatif = LOW)
    app->raw_buffer[app->raw_buffer_write] = level ? (int32_t)duration : -(int32_t)duration;
    app->raw_buffer_write = next_write;
    app->capture_started = true;
}

// Nombre de répétitions pour le TX
#define TX_REPEAT_COUNT 5

// --- Thread de capture async ---
static int32_t subghz_worker_thread(void* context) {
    SubGhzApp* app = context;

    FURI_LOG_I(TAG, "Thread de capture async demarre");

    // Attendre que des données arrivent puis les sauvegarder périodiquement
    uint32_t last_write_pos = 0;
    uint32_t silence_count = 0;

    while(app->is_capturing) {
        size_t current_write = app->raw_buffer_write;

        if(current_write != last_write_pos) {
            // Nouvelles données reçues
            app->signal_count = current_write;
            silence_count = 0;
            last_write_pos = current_write;
        } else if(app->capture_started) {
            // Pas de nouvelles données
            silence_count++;

            // Après 500ms de silence et si on a des données, sauvegarder
            if(silence_count > 50 && app->raw_buffer_write > 100) {
                FURI_LOG_I(
                    TAG,
                    "Silence detecte, sauvegarde de %u samples",
                    (unsigned int)app->raw_buffer_write);

                // Sauvegarder les données
                Storage* storage = furi_record_open(RECORD_STORAGE);
                Stream* stream = file_stream_alloc(storage);

                if(file_stream_open(
                       stream,
                       furi_string_get_cstr(app->file_path),
                       FSAM_WRITE,
                       FSOM_OPEN_APPEND)) {
                    FuriString* line = furi_string_alloc();
                    furi_string_printf(line, "RAW_Data:");

                    size_t count = 0;
                    for(size_t i = 0; i < app->raw_buffer_write && i < RAW_BUFFER_SIZE; i++) {
                        furi_string_cat_printf(line, " %ld", (long)app->raw_buffer[i]);
                        count++;

                        // Nouvelle ligne tous les 512 samples
                        if(count % 512 == 0) {
                            furi_string_cat_printf(line, "\n");
                            stream_write_string(stream, line);
                            furi_string_printf(line, "RAW_Data:");
                        }
                    }

                    // Écrire le reste
                    if(count % 512 != 0) {
                        furi_string_cat_printf(line, "\n");
                        stream_write_string(stream, line);
                    }

                    furi_string_free(line);
                    file_stream_close(stream);
                    FURI_LOG_I(TAG, "Sauvegarde terminee: %u samples", (unsigned int)count);
                }

                stream_free(stream);
                furi_record_close(RECORD_STORAGE);

                // Reset le buffer pour le prochain signal
                app->raw_buffer_write = 0;
                app->raw_buffer_read = 0;
                app->capture_started = false;
                silence_count = 0;
            }
        }

        furi_delay_ms(10);
    }

    // Sauvegarder les données restantes
    if(app->raw_buffer_write > 10) {
        FURI_LOG_I(TAG, "Sauvegarde finale de %u samples", (unsigned int)app->raw_buffer_write);

        Storage* storage = furi_record_open(RECORD_STORAGE);
        Stream* stream = file_stream_alloc(storage);

        if(file_stream_open(
               stream, furi_string_get_cstr(app->file_path), FSAM_WRITE, FSOM_OPEN_APPEND)) {
            FuriString* line = furi_string_alloc();
            furi_string_printf(line, "RAW_Data:");

            for(size_t i = 0; i < app->raw_buffer_write && i < RAW_BUFFER_SIZE; i++) {
                furi_string_cat_printf(line, " %ld", (long)app->raw_buffer[i]);
                if((i + 1) % 512 == 0 || i == app->raw_buffer_write - 1) {
                    furi_string_cat_printf(line, "\n");
                    stream_write_string(stream, line);
                    if(i < app->raw_buffer_write - 1) {
                        furi_string_printf(line, "RAW_Data:");
                    }
                }
            }

            furi_string_free(line);
            file_stream_close(stream);
        }

        stream_free(stream);
        furi_record_close(RECORD_STORAGE);
    }

    FURI_LOG_I(TAG, "Thread de capture arrete");
    return 0;
}

// --- Démarrer la capture ---
static void start_capture(SubGhzApp* app) {
    FURI_LOG_I(TAG, "Demarrage de la capture async...");

    // Allouer le buffer
    app->raw_buffer = malloc(RAW_BUFFER_SIZE * sizeof(int32_t));
    if(!app->raw_buffer) {
        FURI_LOG_E(TAG, "Erreur allocation buffer");
        return;
    }
    app->raw_buffer_write = 0;
    app->raw_buffer_read = 0;
    app->capture_started = false;
    g_app = app;

    // Initialiser la radio avec le preset OOK 650kHz
    furi_hal_subghz_reset();
    furi_hal_subghz_idle();
    furi_hal_subghz_load_custom_preset(subghz_device_cc1101_preset_ook_650khz_async_regs);
    furi_hal_subghz_set_frequency_and_path(MY_FREQUENCY);

    FURI_LOG_I(TAG, "Radio initialisee sur %lu Hz", (unsigned long)MY_FREQUENCY);

    // Créer le fichier avec les en-têtes
    Storage* storage = furi_record_open(RECORD_STORAGE);
    storage_common_mkdir(storage, "/ext/subghz");
    storage_common_mkdir(storage, "/ext/subghz/captures");

    Stream* stream = file_stream_alloc(storage);
    if(file_stream_open(stream, SUBGHZ_RAW_FILE_PATH, FSAM_WRITE, FSOM_CREATE_ALWAYS)) {
        stream_write_cstring(stream, "Filetype: Flipper SubGhz RAW File\n");
        stream_write_cstring(stream, "Version: 1\n");
        FuriString* freq_line = furi_string_alloc();
        furi_string_printf(freq_line, "Frequency: %lu\n", (unsigned long)MY_FREQUENCY);
        stream_write_string(stream, freq_line);
        stream_write_cstring(stream, "Preset: FuriHalSubGhzPresetOok650Async\n");
        stream_write_cstring(stream, "Protocol: RAW\n");
        furi_string_free(freq_line);
    }
    file_stream_close(stream);
    stream_free(stream);
    furi_record_close(RECORD_STORAGE);

    // Démarrer la capture async
    app->is_capturing = true;
    app->signal_count = 0;

    furi_hal_subghz_start_async_rx(capture_callback, app);
    FURI_LOG_I(TAG, "Capture async demarree");

    // Démarrer le thread de monitoring/sauvegarde
    app->worker_thread = furi_thread_alloc();
    furi_thread_set_name(app->worker_thread, "SubGhzCapture");
    furi_thread_set_stack_size(app->worker_thread, 4096);
    furi_thread_set_context(app->worker_thread, app);
    furi_thread_set_callback(app->worker_thread, subghz_worker_thread);
    furi_thread_start(app->worker_thread);

    FURI_LOG_I(TAG, "Capture sur %lu Hz", (unsigned long)MY_FREQUENCY);
}

// --- Arrêter la capture ---
static void stop_capture(SubGhzApp* app) {
    if(app->is_capturing) {
        FURI_LOG_I(TAG, "Arret de la capture async...");

        app->is_capturing = false;

        // Arrêter la capture async
        furi_hal_subghz_stop_async_rx();

        // Attendre la fin du thread
        furi_thread_join(app->worker_thread);
        furi_thread_free(app->worker_thread);

        // Libérer le buffer
        if(app->raw_buffer) {
            free(app->raw_buffer);
            app->raw_buffer = NULL;
        }
        g_app = NULL;

        furi_hal_subghz_idle();
        furi_hal_subghz_sleep();

        FURI_LOG_I(TAG, "Capture arretee. %lu samples", app->signal_count);
    }
}

// --- Fonction pour charger et afficher les enregistrements ---
static void load_recordings(SubGhzApp* app) {
    FURI_LOG_I(TAG, "Chargement des enregistrements...");

    furi_string_reset(app->display_content);

    Storage* storage = furi_record_open(RECORD_STORAGE);
    Stream* stream = file_stream_alloc(storage);

    if(file_stream_open(stream, SUBGHZ_RAW_FILE_PATH, FSAM_READ, FSOM_OPEN_EXISTING)) {
        uint64_t file_size = stream_size(stream);

        // Afficher la taille du fichier
        furi_string_printf(app->display_content, "File size: %llu bytes\n", file_size);
        furi_string_cat_printf(app->display_content, "Signals: %lu\n\n", app->signal_count);

        // Lire les 10 premières lignes
        FuriString* line = furi_string_alloc();
        int line_count = 0;

        while(stream_read_line(stream, line) && line_count < 10) {
            furi_string_cat_printf(app->display_content, "%s", furi_string_get_cstr(line));
            line_count++;
        }

        if(line_count == 10) {
            furi_string_cat_printf(app->display_content, "...\n");
        }

        furi_string_free(line);
        FURI_LOG_I(TAG, "Fichier charge avec succes");
    } else {
        furi_string_printf(app->display_content, "Fichier non trouve:\n%s", SUBGHZ_RAW_FILE_PATH);
        FURI_LOG_W(TAG, "Impossible de charger le fichier");
    }

    file_stream_close(stream);
    stream_free(stream);
    furi_record_close(RECORD_STORAGE);
}

// --- Fonction pour rejouer les signaux avec l'API async TX ---
static int32_t subghz_replay_thread(void* context) {
    SubGhzApp* app = context;

    FURI_LOG_I(TAG, "Demarrage du replay async...");

    // Allouer le buffer TX si nécessaire
    if(app->tx_buffer == NULL) {
        app->tx_buffer = malloc(RAW_BUFFER_SIZE * sizeof(int32_t));
        if(app->tx_buffer == NULL) {
            FURI_LOG_E(TAG, "Echec allocation tx_buffer");
            app->is_replaying = false;
            app->replay_finished = true;
            return 0;
        }
    }
    app->tx_buffer_size = 0;

    // Charger les données RAW depuis le fichier
    Storage* storage = furi_record_open(RECORD_STORAGE);
    Stream* stream = file_stream_alloc(storage);

    FURI_LOG_I(TAG, "Ouverture fichier: %s", SUBGHZ_RAW_FILE_PATH);

    if(file_stream_open(stream, SUBGHZ_RAW_FILE_PATH, FSAM_READ, FSOM_OPEN_EXISTING)) {
        FuriString* line = furi_string_alloc();
        bool header_done = false;
        int line_count = 0;
        int raw_lines = 0;

        FURI_LOG_I(TAG, "Fichier ouvert, chargement des donnees RAW...");

        while(stream_read_line(stream, line) && app->tx_buffer_size < RAW_BUFFER_SIZE) {
            line_count++;
            const char* line_str = furi_string_get_cstr(line);

            // Log des 10 premieres lignes pour debug
            if(line_count <= 10) {
                FURI_LOG_I(TAG, "Ligne %d: %.60s", line_count, line_str);
            }

            // Sauter les en-têtes
            if(!header_done) {
                if(strstr(line_str, "Protocol:") != NULL) {
                    header_done = true;
                    FURI_LOG_I(TAG, "Header Protocol trouve a la ligne %d", line_count);
                }
                continue;
            }

            // Parser les lignes RAW_Data
            if(strstr(line_str, "RAW_Data:") != NULL) {
                raw_lines++;
                // Format: "RAW_Data: timing1 timing2 timing3 ..."
                const char* ptr = line_str + 9; // Sauter "RAW_Data:"
                size_t samples_this_line = 0;

                while(*ptr && app->tx_buffer_size < RAW_BUFFER_SIZE) {
                    // Sauter les espaces
                    while(*ptr == ' ')
                        ptr++;
                    if(*ptr == '\0' || *ptr == '\n' || *ptr == '\r') break;

                    // Parser le nombre (peut être négatif)
                    char* end;
                    long timing = strtol(ptr, &end, 10);
                    if(end == ptr) break; // Pas de nombre trouvé

                    if(timing != 0) {
                        app->tx_buffer[app->tx_buffer_size++] = (int32_t)timing;
                        samples_this_line++;
                    }
                    ptr = end;
                }

                if(raw_lines <= 3) {
                    FURI_LOG_I(
                        TAG,
                        "RAW_Data ligne %d: %u samples",
                        raw_lines,
                        (unsigned int)samples_this_line);
                }
            }
        }

        furi_string_free(line);
        FURI_LOG_I(
            TAG,
            "Fichier lu: %d lignes, %d lignes RAW, %u samples total",
            line_count,
            raw_lines,
            (unsigned int)app->tx_buffer_size);
    } else {
        FURI_LOG_E(TAG, "ERREUR: Impossible d'ouvrir le fichier %s", SUBGHZ_RAW_FILE_PATH);
    }

    file_stream_close(stream);
    stream_free(stream);
    furi_record_close(RECORD_STORAGE);

    // Vérifier qu'on a des données à envoyer
    if(app->tx_buffer_size == 0) {
        FURI_LOG_E(TAG, "Aucune donnee RAW a envoyer");
        furi_delay_ms(500); // Attendre un peu avant de mettre les flags
        app->is_replaying = false;
        app->replay_finished = true;
        return 0;
    }

    FURI_LOG_I(TAG, "Donnees chargees: %u samples", (unsigned int)app->tx_buffer_size);
    // Afficher quelques samples pour debug
    for(size_t i = 0; i < 5 && i < app->tx_buffer_size; i++) {
        FURI_LOG_I(TAG, "Sample[%u] = %ld", (unsigned int)i, (long)app->tx_buffer[i]);
    }

    // Initialiser la radio avec le preset OOK
    furi_hal_subghz_reset();
    furi_hal_subghz_idle();
    furi_hal_subghz_load_custom_preset(subghz_device_cc1101_preset_ook_650khz_async_regs);
    furi_hal_subghz_set_frequency_and_path(MY_FREQUENCY);

    app->replay_count = app->tx_buffer_size;

    FURI_LOG_I(
        TAG,
        "Demarrage TX, %u samples, %d repetitions",
        (unsigned int)app->tx_buffer_size,
        TX_REPEAT_COUNT);

    // Transmission manuelle - plus stable que async
    for(int repeat = 0; repeat < TX_REPEAT_COUNT && app->is_replaying; repeat++) {
        FURI_LOG_I(TAG, "TX repeat %d/%d", repeat + 1, TX_REPEAT_COUNT);

        for(size_t i = 0; i < app->tx_buffer_size && app->is_replaying; i++) {
            int32_t timing = app->tx_buffer[i];
            bool level = timing > 0;
            uint32_t duration_us = (timing > 0) ? (uint32_t)timing : (uint32_t)(-timing);

            if(level) {
                furi_hal_subghz_tx();
            } else {
                furi_hal_subghz_idle();
            }

            // Attendre la durée (en microsecondes)
            if(duration_us > 1000) {
                furi_delay_ms(duration_us / 1000);
                furi_delay_us(duration_us % 1000);
            } else {
                furi_delay_us(duration_us);
            }
        }

        furi_hal_subghz_idle();
        furi_delay_ms(100);
    }

    FURI_LOG_I(TAG, "=== TX TERMINE ===");

    // Mettre à jour les flags immédiatement (pas de sleep qui bloque)
    app->is_replaying = false;
    app->replay_finished = true;

    FURI_LOG_I(TAG, "=== REPLAY COMPLETE ===");

    return 0;
}

// --- Point d'entrée principal ---
int32_t sub_ghz_app(void* p) {
    UNUSED(p);

    FURI_LOG_I(TAG, "SubGhz App demarree");

    // Initialiser la structure de l'app
    SubGhzApp* app = malloc(sizeof(SubGhzApp));
    app->is_capturing = false;
    app->signal_count = 0;
    app->file_path = furi_string_alloc_set(SUBGHZ_RAW_FILE_PATH);
    app->event_queue = furi_message_queue_alloc(8, sizeof(InputEvent));
    app->app_state = 0; // Mode capture par défaut
    app->display_content = furi_string_alloc();
    app->is_replaying = false;
    app->replay_finished = false;
    app->replay_count = 0;
    app->replay_thread = NULL;

    // Initialiser les buffers async
    app->raw_buffer = NULL;
    app->raw_buffer_write = 0;
    app->raw_buffer_read = 0;
    app->capture_started = false;
    app->tx_buffer = NULL;
    app->tx_buffer_size = 0;
    app->tx_buffer_index = 0;
    app->tx_repeat_current = 0;

    // Mise en place de l'interface graphique
    app->view_port = view_port_alloc();
    view_port_draw_callback_set(app->view_port, render_callback, app);
    view_port_input_callback_set(app->view_port, input_callback, app->event_queue);

    app->gui = furi_record_open(RECORD_GUI);
    gui_add_view_port(app->gui, app->view_port, GuiLayerFullscreen);

    // Boucle d'événements
    InputEvent event;
    bool running = true;
    while(running) {
        if(furi_message_queue_get(app->event_queue, &event, 100) == FuriStatusOk) {
            if(event.type == InputTypeShort) {
                if(event.key == InputKeyBack) {
                    if(app->app_state == 0) {
                        running = false;
                    } else if(app->app_state == 2) {
                        // Arrêter le replay si en cours
                        if(app->is_replaying) {
                            app->is_replaying = false;
                        }
                        // Attendre et nettoyer le thread
                        if(app->replay_thread != NULL) {
                            furi_thread_join(app->replay_thread);
                            furi_thread_free(app->replay_thread);
                            app->replay_thread = NULL;
                        }
                        app->replay_finished = false;
                        app->app_state = 1; // Retourner au mode affichage
                    } else {
                        // Revenir au mode capture
                        app->app_state = 0;
                    }
                    view_port_update(app->view_port);
                } else if(event.key == InputKeyOk && app->app_state == 0) {
                    // Basculer la capture (seulement en mode capture)
                    if(app->is_capturing) {
                        stop_capture(app);
                    } else {
                        start_capture(app);
                    }
                    view_port_update(app->view_port);
                } else if(event.key == InputKeyOk && app->app_state == 1) {
                    // Passer au mode replay depuis affichage
                    app->app_state = 2;
                    app->is_replaying = true;
                    app->replay_finished = false;
                    app->replay_count = 0;

                    // Démarrer le thread de replay (non bloquant)
                    app->replay_thread = furi_thread_alloc();
                    furi_thread_set_name(app->replay_thread, "SubGhzReplay");
                    furi_thread_set_stack_size(app->replay_thread, 2048);
                    furi_thread_set_context(app->replay_thread, app);
                    furi_thread_set_callback(app->replay_thread, subghz_replay_thread);
                    furi_thread_start(app->replay_thread);

                    view_port_update(app->view_port);
                } else if(event.key == InputKeyOk && app->app_state == 2) {
                    // Envoyer le signal (si pas déjà en cours)
                    if(!app->is_replaying) {
                        // Nettoyer l'ancien thread si nécessaire
                        if(app->replay_thread != NULL) {
                            furi_thread_join(app->replay_thread);
                            furi_thread_free(app->replay_thread);
                            app->replay_thread = NULL;
                        }

                        app->is_replaying = true;
                        app->replay_finished = false;
                        app->replay_count = 0;
                        FURI_LOG_I(TAG, "Lancement du replay depuis OK"); // Debug

                        app->replay_thread = furi_thread_alloc();
                        furi_thread_set_name(app->replay_thread, "SubGhzReplay");
                        furi_thread_set_stack_size(app->replay_thread, 2048);
                        furi_thread_set_context(app->replay_thread, app);
                        furi_thread_set_callback(app->replay_thread, subghz_replay_thread);
                        furi_thread_start(app->replay_thread);
                    }
                    view_port_update(app->view_port);
                } else if(event.key == InputKeyLeft && app->app_state == 0) {
                    // Afficher les enregistrements
                    app->app_state = 1;
                    load_recordings(app);
                    view_port_update(app->view_port);
                }
            }
        }

        // Mettre à jour l'affichage périodiquement
        if(app->is_capturing || app->is_replaying || (app->app_state == 2)) {
            view_port_update(app->view_port);
        }

        // Vérifier si le thread de replay est terminé et mettre à jour l'UI
        if(app->replay_thread != NULL && !app->is_replaying && app->replay_finished) {
            furi_thread_join(app->replay_thread);
            furi_thread_free(app->replay_thread);
            app->replay_thread = NULL;
            FURI_LOG_I(TAG, "Thread replay nettoye, UI mise a jour");
            view_port_update(app->view_port);
        }
    }

    // Nettoyage
    FURI_LOG_I(TAG, "Arret de l'app");

    if(app->is_capturing) {
        stop_capture(app);
    }

    // Nettoyer le thread de replay si nécessaire
    if(app->replay_thread != NULL) {
        app->is_replaying = false; // Arrêter le replay
        furi_thread_join(app->replay_thread);
        furi_thread_free(app->replay_thread);
    }

    gui_remove_view_port(app->gui, app->view_port);
    view_port_free(app->view_port);
    furi_record_close(RECORD_GUI);
    furi_message_queue_free(app->event_queue);
    furi_string_free(app->file_path);
    furi_string_free(app->display_content);

    // Libérer les buffers async
    if(app->raw_buffer != NULL) {
        free(app->raw_buffer);
    }
    if(app->tx_buffer != NULL) {
        free(app->tx_buffer);
    }

    free(app);

    return 0;
}
